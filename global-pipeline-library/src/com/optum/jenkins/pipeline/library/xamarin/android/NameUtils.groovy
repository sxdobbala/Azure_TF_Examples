package com.optum.jenkins.pipeline.library.xamarin.android

class NameUtils implements Serializable {
  def jenkins

  NameUtils() throws Exception {
    throw new Exception('`this` must be passed when creating new class instance e.g. new Classname(this) instead of new Classname(). ' +
      'This enables access to jenkinsfile steps, global variables, functions and envvars.')
  }

  NameUtils(jenkins) {
    this.jenkins = jenkins
  }

/**
 * Come up with names for apk artifacts, if not specified
 * Uses existing apk as a naming convention for signedApk
 * Use this function AFTER `xbuild package`
 *
 * @params appName String Required Name of app
 *
 * @params folderPath String Optional Path to folder where apk is.
 *      Format: leading '/', no trailing '/'
 * @params rootDir String Optional Path of folders between workspace root
 *      and appName. For most projects, is empty
 * @params inputApk String Optional Explicitly set name of inputApk
 * @params signedApk String Optional Explicitly set name of signedApk
 * @params endApk String Optional Explicitly set name of endApk
 *
 */
  def makeDefaultApkNames(Map<String, Object> params) {
    def defaults = [
      appName   : '',
      folderPath: '/Droid/bin/Release',
      rootDir   : '',
      inputApk  : '',
      signedApk : '',
      endApk    : '',
    ]
    def config = defaults + params

    jenkins.echo "makeDefaultApkNames arguments: $config"
    def releasePath = "$config.rootDir$config.appName$config.folderPath"

    // Find the existing apk generated by xbuild and pull out the name
    def existingApk = sh(
      returnStdout: true,
      script: 'ls ' + "$releasePath | grep -E " + /'([a-zA-Z0-9\.]+)\.apk$'/
        + " | sed -E 's/.apk\$//' | tr -d '\\n' ")

    // Assign new values to apk names if not specified
    def inputApk = (config.inputApk == '' ?
      "$releasePath/${existingApk}.apk" :
      "$config.inputApk")

    def signedApk = (config.signedApk == '' ?
      "$releasePath/${existingApk}_signed.apk" :
      "$config.signedApk")

    def endApk = (config.endApk == '' ?
      "$releasePath/${config.appName}.apk" :
      "$config.endApk")

    return [
      inputApk : "$inputApk",
      signedApk: "$signedApk",
      endApk   : "$endApk"
    ]
  }

/**
 * Replace the BUILD_ENVIRONMENT string in AppSetup.cs
 *
 * @params appSetupPath String Required Path to AppSetup.cs
 * @params buildEnv String Required Name of the environment
 */
  def setEnvironment(Map<String, Object> params) {
    def defaults = [
      appSetupPath: '',
      buildEnv    : ''
    ]
    def config = defaults + params

    jenkins.echo "setEnvironment arguments: $config"
    jenkins.sh "sed -i \'\' \'s/.*public const string BUILD_ENVIRONMENT =.*/public const string BUILD_ENVIRONMENT = $config.buildEnv;/\' $config.appSetupPath/AppSetup.cs"
  }

/**
 * Wrapper for backwards compatibility.
 */
  def makeDefaultApkNames(Closure body) {
    def config = [:]
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()
    makeDefaultApkNames(config)
  }

/**
 * Wrapper for backwards compatibility.
 */
  def setEnvironment(Closure body) {
    def config = [:]
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()
    setEnvironment(config)
  }
}
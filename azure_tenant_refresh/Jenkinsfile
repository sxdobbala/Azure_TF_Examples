import groovy.json.JsonOutput

if (env.BRANCH_NAME == 'master' || env.CHANGE_ID) {

  def log = []
  def launchpadFailureExists = false 
  def tenants
  def loggingRoleName
  def loggingRoleFile
  def centralObjectIds = [
    "5e87fb0c-99e9-499b-912f-b83caf5430be": "b19e565f-4293-419b-a85f-bcc19638dc2a",
    "db05faca-c82a-4b9d-b9c5-0f64b6755421": "f7fd38a2-1ae9-4015-b899-fc7d65de12ef",
    "85f46a4d-265f-41b9-aaef-c494b7617e7f": "3a1efcca-cc44-46ab-96d6-6ea267c3e428"
  ]
  def centralManagementLocation = "centralus"
  def environment
  def terraformPlanFlags = "-out=tfplan -input=false -no-color"
  def terraformApplyFlags = "-input=false -no-color -auto-approve=true tfplan"
  def exportLocations = "australiacentral australiacentral2 australiaeast australiasoutheast brazilsouth canadacentral canadaeast centralindia centralus eastasia eastus eastus2 francecentral francesouth japaneast japanwest koreacentral koreasouth northcentralus northeurope southcentralus southindia southeastasia uksouth ukwest westcentralus westeurope westindia westus westus2 global"              
  def commitMessage
  def targetingOneSubscription = false
  
  def eventHubKeyVaultName
  def eventHubKeyVaultSecret
  def eventHubResourceGroupName
  def eventHubNamespace

  // Move hard-coded values like this 
  // to the yml file when switching to the 
  // base pipeline.
  def ccAzuEisReadSpObjectIds = [
    "5e87fb0c-99e9-499b-912f-b83caf5430be": "73bb0605-781d-4b91-8a6f-c52ec8c440b8",
    "db05faca-c82a-4b9d-b9c5-0f64b6755421": "7bd64576-cbfe-4cd0-af06-a946df9c5f5b"
  ]
    
  node('docker-azure-slave') {
    checkout scm

    commitMessage = sh (script: "git log -1 --pretty=%B", returnStdout: true)
    
    // Assignments
    if (env.BRANCH_NAME == "master") {
      tenants = readYaml file: 'tenants.yml'
      if (commitMessage != null && commitMessage.contains("[ci]")) {
        targetingOneSubscription = true
        tenants = constructTenants(commitMessage, tenants)
      }
      loggingRoleName = "LoggingToEventHub"
      loggingRoleFile = "LoggingToEventHub.json"
      environment = "prod"
    } else if (env.CHANGE_ID) {
      tenants = readYaml file: './tests/test_tenants.yml'
      loggingRoleName = "LaunchpadRolePR"
      loggingRoleFile = "LaunchpadRolePR.json"
      environment = "pr"
    } else {
      return
    }
  }

  // Loop through tenants and subscriptions
  tenants.each { tenantId, subscriptions ->
    def tenantList = []
    def centralManagementSubscription = [:]                 
    def centralSubscription = subscriptions.find { it.contains("central_mgmt_id") }
    def output

    if (centralSubscription != null) {

      // Ask for manual approval before deploying launchpad to the subscriptions in the tenant, 
      // but not for PRs since it is run against test subscriptions
      if (!env.CHANGE_ID) {
        timeout(time: 10, unit: "DAYS") {
          input "Run launchpad on subscription(s) in tenant ${tenantId}?" 
        }
      }

      node('docker-azure-slave') {
        checkout scm

        // Stage: Deploying to Central Management Subscription
        stage ("Central Management Subscription deployment for tenant ${tenantId}") {
          withCredentials([
            azureServicePrincipal(credentialsId: centralSubscription, subscriptionIdVariable: 'ARM_SUBSCRIPTION_ID', clientIdVariable: 'ARM_CLIENT_ID', clientSecretVariable: 'ARM_CLIENT_SECRET', tenantIdVariable: 'ARM_TENANT_ID'),
            string(credentialsId: 'SPLUNK_SAS_TOKEN', variable: 'splunkSASToken')
          ]) {
            def launchpadResourceGroup = ARM_SUBSCRIPTION_ID.substring(0, 8) + environment + "launchpad" // Do not want to conflict with other storage accounts!

            output = centralManagementSubscriptionDeployment(centralObjectIds[tenantId], launchpadResourceGroup, centralManagementLocation, terraformPlanFlags, terraformApplyFlags, splunkSASToken)
            eventHubKeyVaultName = output.event_hub_vault_name.value
            eventHubKeyVaultSecret = output.event_hub_secret_name.value
            eventHubResourceGroupName = output.event_hub_resource_group_name.value
            eventHubNamespace = output.event_hub_namespace_name.value

            if (output == null) {
              launchpadFailureExists = true
              centralManagementSubscription.status = "Failed"
              centralManagementSubscription.loggingResourceGroupName = ""
            } else {
              centralManagementSubscription.status = "Succeeded"
              centralManagementSubscription.loggingResourceGroupName = output.event_hub_resource_group_name.value
            }
            centralManagementSubscription.subscription = ARM_SUBSCRIPTION_ID
          }
        }

        // Stage: Create a role definition in the Central Management Subscription
        stage ('Create Event Hub role definition') {
          withCredentials([
            azureServicePrincipal(credentialsId: centralSubscription, subscriptionIdVariable: 'ARM_SUBSCRIPTION_ID', clientIdVariable: 'ARM_CLIENT_ID', clientSecretVariable: 'ARM_CLIENT_SECRET', tenantIdVariable: 'ARM_TENANT_ID')
          ]) {
            createEventHubRoleDefinition(loggingRoleName, loggingRoleFile, ARM_SUBSCRIPTION_ID)
          }
        }

        subscriptions.each { subscription ->
          def exportActivityLogStatus = ""
          def applyPoliciesStatus = ""
          def assignCcAzuEisReadSpRoleStatus = ""

          // Stage: deploy launchpad to each subscription
          stage ("Subscription ${subscription} deployment") {
            withCredentials([
              azureServicePrincipal(credentialsId: subscription, subscriptionIdVariable: 'ARM_SUBSCRIPTION_ID', clientIdVariable: 'ARM_CLIENT_ID', clientSecretVariable: 'ARM_CLIENT_SECRET', tenantIdVariable: 'ARM_TENANT_ID'),
              azureServicePrincipal(credentialsId: centralSubscription, subscriptionIdVariable: 'C_ARM_SUBSCRIPTION_ID', clientIdVariable: 'C_ARM_CLIENT_ID', clientSecretVariable: 'C_ARM_CLIENT_SECRET', tenantIdVariable: 'C_ARM_TENANT_ID')
            ]) {
              // Assign the role so the subscription's SP can export logs
              assignEventHubRole(loggingRoleName)

              // Export activity logs to central management subscription's event hub
              if (centralManagementSubscription.status == "Succeeded") {
                if (exportActivityLogs(exportLocations, output.subscription_id.value, output.event_hub_resource_group_name.value, output.event_hub_namespace_name.value)) {
                  exportActivityLogStatus = "Succeeded"
                } else {
                  launchpadFailureExists = true
                  exportActivityLogStatus = "Failed"
                }
              } else {
                exportActivityLogStatus = "Skipped"
              } 

              // Apply policies
              if (applyPolicies()) {
                applyPoliciesStatus = "Succeeded"
              } else {
                launchpadFailureExists = true 
                applyPoliciesStatus = "Failed"
              }

              if (ccAzuEisReadSpObjectIds.containsKey(tenantId)) {
                if (assignAADRole("Reader", ccAzuEisReadSpObjectIds[tenantId])) {
                  assignCcAzuEisReadSpRoleStatus = "Succeeded"
                } else {
                  assignCcAzuEisReadSpRoleStatus = "Failed"
                }
              }

              def activityLogResourceGroup = centralManagementSubscription.status == "Succeeded" ? output.event_hub_resource_group_name.value : ""
              tenantList.add([
                subscription: ARM_SUBSCRIPTION_ID,
                exportActivityLogStatus: exportActivityLogStatus,
                applyPoliciesStatus: applyPoliciesStatus,
                activityLogResourceGroup: activityLogResourceGroup,
                assignCcAzuEisReadSpRole: assignCcAzuEisReadSpRoleStatus
              ])
            }
          }
        }
      }
    } 

    log.add([
      tenant: tenantId,
      centralManagementSubscription: centralManagementSubscription,
      dataset: tenantList
    ])
  }
    
  node() {
    archiveLaunchpadLog(log)
    
    if (env.CHANGE_ID && launchpadFailureExists) {
      currentBuild.result = 'FAILURE'
      return
    }
    
    sendLaunchpadStatusEmail(launchpadFailureExists)
  }

  if (env.CHANGE_ID) {
    runIntegrationTest(environment, eventHubKeyVaultName, loggingRoleName, eventHubNamespace, eventHubResourceGroupName, eventHubKeyVaultSecret)
  }
}

// Run integration tests
// WIP
def runIntegrationTest(environment, eventHubKeyVaultName, loggingRoleName, eventHubNamespace, eventHubResourceGroupName, eventHubKeyVaultSecret){
  node('docker-cc-portal-slave') {
    checkout scm
    
    stage('Integration Tests') {
      def centralSubscription = "Keystone_Prod_PR_central_mgmt_id"

      
      withCredentials([azureServicePrincipal(credentialsId: centralSubscription,
                        subscriptionIdVariable: 'ARM_SUBSCRIPTION_ID',
                        clientIdVariable: 'ARM_CLIENT_ID',
                        clientSecretVariable: 'ARM_CLIENT_SECRET',
                        tenantIdVariable: 'ARM_TENANT_ID')
      ]) {
        def launchpadResourceGroup = ARM_SUBSCRIPTION_ID.substring(0, 8) + environment + "launchpad"
        try {
          sh """
          . /etc/profile.d/jenkins.sh

          python3 -m venv venv
          . venv/bin/activate
          pip3 install -r tests/requirements.txt

          az --version
                
          # Pytest
          pytest --junitxml pytest.xml --centralManagementRG ${launchpadResourceGroup} --eventHubKeyVault ${eventHubKeyVaultName} --storageAccount ${launchpadResourceGroup} --storageContainer tfstate --hubRole ${loggingRoleName} --exportActivityLog "default" --eventHubNamespace ${eventHubNamespace} --eventHubResourceGroup ${eventHubResourceGroupName} --eventHubKeyVaultSecret ${eventHubKeyVaultSecret}
          """
        } finally {
          junit 'pytest.xml'
        }
      }
    }
  }
}

// When the commit message is of the following format: "[ci] {\"tenant\":\"xxx\",\"subscription\":\"xxx\"}",
// launchpad will be run against that specific subscription. This method creates the 
// tenants map with the central subscription for that tenant and the target subscription.
// This assumes that commit messages that contain "[ci]" are only used for targeting one subscription at this time  
def constructTenants(commitMessage, tenants) {
  def targetTenant, targetSubscription, centralSubscription
  try {
    def parsedCommit = readJSON text: commitMessage.split(" ")[1]
    targetTenant = parsedCommit["tenant"]
    targetSubscription = parsedCommit["subscription"]
    centralSubscription = tenants[targetTenant].find { it.contains("central_mgmt_id") }
  } catch (Exception e) {
    error("Could not parse commit message")
  }
  if (targetTenant != null && targetSubscription != null && centralSubscription != null) {
    return [(targetTenant):[centralSubscription, targetSubscription]] 
  }
  error("Error creating tenant list to target single subscription. Tenant: ${targetTenant}, Subscription: ${targetSubscription}")
}

// Deploy to Central Management subscription
// Returns output from terraform run if successfull
// else returns null
def centralManagementSubscriptionDeployment(splunkSPObjectId, launchpadResourceGroup, centralManagementLocation, terraformPlanFlags, terraformApplyFlags, splunkSASToken) {
  echo "Central Management Subscription Deployment"
  try {                
    sh """ 
    export TERRAFORM_VERSION=0.11
    . /etc/profile.d/jenkins.sh
              
    cd ./central_management_subscription
    rm -rf .terraform/
    rm -rf .tf-prepare/

    export TF_VAR_location="${centralManagementLocation}"
    export TF_VAR_group_uuid="${splunkSPObjectId}"
    export TF_VAR_splunk_sas_token="${splunkSASToken}"
    curl https://github.optum.com/raw/CommercialCloud-EAC/python-scripts/v0.3.0/azure_remote_state_init/remote_state_init.py | python3.5 - -g ${launchpadResourceGroup} -sa ${launchpadResourceGroup} -sc tfstate -sf terraform.tfstate

    terraform plan ${terraformPlanFlags}
    terraform apply ${terraformApplyFlags}

    terraform output -json > output.json
    """
    def output = readJSON file: './central_management_subscription/output.json'
    return output
  } catch (Exception e) {
    return null
  }
}

// Creates a Role in the central subscription that allows subscriptions to use the
// central event hub
def createEventHubRoleDefinition(loggingRoleName, loggingRoleFile, subscriptionId) {
  echo "Creating role definition"
  def roleDefinition = [
    "name": loggingRoleName,
    "IsCustom": true,
    "Description": "Allows user to get the keys needed to access an event hub.",
    "Actions": [
      "Microsoft.ServiceBus/namespaces/authorizationrules/listkeys/action",
      "Microsoft.EventHub/namespaces/authorizationRules/listkeys/action"
    ],
    "NotActions": [
    ],
    "AssignableScopes": [
      "/subscriptions/${subscriptionId}"
    ]
  ]
  def roleDefinitionJson = JsonOutput.toJson(roleDefinition)
  writeFile(file: loggingRoleFile, text: roleDefinitionJson)
  try {
    sh """
    . /etc/profile.d/jenkins.sh
              
    az login --service-principal -u ${ARM_CLIENT_ID} -p ${ARM_CLIENT_SECRET} --tenant ${ARM_TENANT_ID}
    az account set --subscription ${subscriptionId} 
    if ! az role definition create --role-definition ./${loggingRoleFile} 
    then
      echo "Create failed"
      az role definition update --role-definition ./${loggingRoleFile}   
    fi
    """
  } catch (Exception ex) {
    echo "Failed role definition"
  } finally {
    sh """
    . /etc/profile.d/jenkins.sh
    echo "Removing file"
    rm -f ${loggingRoleFile}
    """
  }
}

// Assign the subscription's SP to the role
def assignEventHubRole(loggingRoleName) {
  echo "Assigning role definition"
  try {
    sh """
    . /etc/profile.d/jenkins.sh

    az login --service-principal -u ${ARM_CLIENT_ID} -p ${ARM_CLIENT_SECRET} --tenant ${ARM_TENANT_ID}
    OBJECTID=\$(az ad sp show --id ${ARM_CLIENT_ID} --output json | jq .objectId | tr -d '"')
    az logout
                
    az login --service-principal -u ${C_ARM_CLIENT_ID} -p ${C_ARM_CLIENT_SECRET} --tenant ${C_ARM_TENANT_ID}
    az account set --subscription ${C_ARM_SUBSCRIPTION_ID}
    az role assignment create --role ${loggingRoleName} --assignee-object-id "\$OBJECTID" --scope "/subscriptions/${C_ARM_SUBSCRIPTION_ID}"
    """
  } catch (Exception ex) {
    echo "Failed the role assignment"
  }
}

// Export activity logs to the Central Subscription's event hub
def exportActivityLogs(exportLocations, centralSubscriptionId, centralSubscriptionResourceGroup, centralSubscriptionNamespace) {
  echo "Exporting Activity Logs"
  try {
    sh """
    . /etc/profile.d/jenkins.sh

    az login --service-principal -u ${ARM_CLIENT_ID} -p ${ARM_CLIENT_SECRET} --tenant ${ARM_TENANT_ID}
    az account set --subscription ${ARM_SUBSCRIPTION_ID}
                      
    az monitor log-profiles create --name default --location null --locations ${exportLocations} --categories Delete Write Action --enabled false --days 0 --service-bus-rule-id "/subscriptions/${centralSubscriptionId}/resourceGroups/${centralSubscriptionResourceGroup}/providers/Microsoft.EventHub/namespaces/${centralSubscriptionNamespace}/authorizationrules/RootManageSharedAccessKey"
    """
    return true
  } catch (Exception ex) {
    return false
  }	
}

def applyPolicies() {
  echo "Applying policies"
  try {
    sh """
    export TERRAFORM_VERSION=0.11
    . /etc/profile.d/jenkins.sh

    cd ./launchpad_subscription/subscription_policies
          
    az login --service-principal -u ${ARM_CLIENT_ID} -p ${ARM_CLIENT_SECRET} --tenant ${ARM_TENANT_ID}
    az account set --subscription ${ARM_SUBSCRIPTION_ID}

    sh ./azure_policy_cli.sh ${ARM_SUBSCRIPTION_ID}
    """
    return true
  } catch (Exception ex) {
    return false
  }
}

// Assigns a role to a service principal
def assignAADRole(roleName, servicePrincipalObjectId) {
  echo "Assigning SP the ${roleName} role"
  try {
    sh """
    . /etc/profile.d/jenkins.sh

    az login --service-principal -u ${ARM_CLIENT_ID} -p ${ARM_CLIENT_SECRET} --tenant ${ARM_TENANT_ID}
    az account set --subscription ${ARM_SUBSCRIPTION_ID}

    # Check if the SP has been assigned the role
    ASSIGNMENTS=\$(az role assignment list --assignee ${servicePrincipalObjectId} --role ${roleName} --scope /subscriptions/${ARM_SUBSCRIPTION_ID} --output json | jq length) 

    # If it has not been assigned yet, assign the SP to the role
    if [ "\$ASSIGNMENTS" = 0 ]; then
      echo "SP not assigned ${roleName} Role"
      az role assignment create --role "${roleName}" --assignee-object-id "${servicePrincipalObjectId}" --scope "/subscriptions/${ARM_SUBSCRIPTION_ID}"
    fi
    """
    return true
  } catch (Exception ex) {
    echo "Failed to assign the SP the ${roleName} role"
    return false
  }
}

// Archive Launchpad Log
def archiveLaunchpadLog(log) {
  echo "Archiving logs"
  def outJson = JsonOutput.toJson(log)
  def prettyJson = JsonOutput.prettyPrint(outJson)
  writeFile(file:'logging.json', text: prettyJson)
  archiveArtifacts artifacts: 'logging.json', fingerprint: true
}

// Sends out an email if any parts of Launchpad failed
def sendLaunchpadStatusEmail(launchpadFailureExists) {
  if (launchpadFailureExists && env.BRANCH_NAME == 'master') {
    echo "Sending email"
    try {
      emailext attachLog: true, attachmentsPattern: 'logging.json', body: "A Launchpad failure has occurred on build ${env.BUILD_NUMBER}: ${env.BUILD_URL}. See attachment.", subject: 'CC: Azure Launchpad Failure', to: 'cc_customerrelations@optum.com'
    } catch (Exception ex) {
      echo "Failed to send Launchpad status email"
    }
  }
}

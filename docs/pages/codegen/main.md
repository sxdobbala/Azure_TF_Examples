---
layout: main
title: Codegen
permalink: codegen/
---

Codegen generates code for a requesting team to help them get started with a working project. Below is some information about its current capabilities.

## Currently available Application Types
There are currently six application types available that the Cloud Scaffolding APIs are able to create:

- [Product Engineering and Data Solutions (PEDS)](peds)
- [SDSS](sdss)
- NODEJS
    - Node JS is an open-source, cross-platform JavaScript run-time environment that executes JavaScript code at server-side. Specifying this as the app type in the BOMLite will create a simple NodeJS application.
- [GO](go)
    - GO is an open source programming language created by Google. Specifying this as the app type in the BOMLite will create a simple GO application.
- [PYTHON](python)
    - A simple Flask-based Python web server
- [ANGULAR](angular)
    - A simple nginx-based Angular application
- [OPI](opi)
    - A boiler plate Spring Boot API to be registered with the Payment Integrity API Catalog

If you're looking for an application type that isn't here and you'd like to contribute it to Codegen, please see our guide on [creating new Application Types](apptypes)

## Selectable Tools
Currently, Codegen supports adding three tools into generated Jenkins pipelines

 - SonarQube
 - Arachni
 - Fortify

You can see how to add these tools on the [Mix-Master main page](../mm)

If you'd like to add a tool to include in Jenkins pipelines, visit [this page](toolsets)

## Deploying to Multiple Environments
Codegen does not directly support deployment to multiple environments. If you want to do it, you will need manually provision the additional environments and make edits to your project's Jenkinsfile after orchestration.

### Provisioning Additional Environments
There are several ways to provision additional environments, but it is highly recommended that you do the provisioning through Mix-Master. This method will ensure that your new environment is set up with the same deployment configuration and app containers that your initial environment has. To do this, simply run an orchestration with a full BOM, only listing a single openshift feature in the feature list.

#### Example Openshift Environment Orchestration
```
{
  "version": "v1",
  "paas": "openshift",
  "description": "For more information about Cloud Scaffolding and what it has just provisioned for you, visit: https://optumdeveloper.com/scaffolding",
  "application": {
    "name": "examplename",
    "team": "exampleteam",
    "projectOwner": "yourmsid",
    "applicationType": "PEDS",
    "subType": "MICROSERVICE"
  },
  "billingInformation": {
    "tmdbNumber": "TMDB-XXXXXXX",
    "askGlobalId": "UHGWM110-YYYYYY"
  },
  "features": [
    {
      "name": "openshift",
      "uri": "https://ocp-ctc-core-nonprod.optum.com",
      "version": "v1",
      "projectAdministrator": "yourmsid",
      "cpu": "1",
      "ram": "1.5",
      "projectName": "exampleteam",
      "description": "Generated by Cloud Scaffolding",
      "applicationName": "examplename",
      "platform": "nonprod-origin",
      "dataCenter": "ctc",
      "environmentZone": "nonprod",
      "networkZone": "core"
    }
  ]
}
```
### Editing Jenkinsfile to Support Other Environments
#### Openshift
In your orchestrated project's jenkinsfile you will find a section labeled "Deploy Image". Below is an example in a project using Openshift:
```
stage('Deploy Image') {
    withCredentials([usernamePassword(credentialsId: env.CREDS_ID, usernameVariable: 'OS_USER', passwordVariable: 'OS_PASS')] {
        sh """
            oc login $PAAS_SERVER -u $OS_USER -p $OS_PASS --insecure-skip-tls-verify=true
            oc project $PAAS_PROJECT
            oc tag $DOCKER_IMAGE $PAAS_APP:$PAAS_APP
            oc deploy $PAAS_APP
            oc logout
        """
    }
}
```
This is the stage that needs to be duplicated for each new environment. Note that you will need to specify the new environment's project name in the environment declaration. For simplicity, it is recommended that you use the same application name in all environments.

Below is an example of an extended pipeline using Openshift:
```
stage('Deploy Image To ENV 1') {
    withCredentials([usernamePassword(credentialsId: env.CREDS_ID, usernameVariable: 'OS_USER', passwordVariable: 'OS_PASS')]) {
        sh """
            oc login $PAAS_SERVER -u $OS_USER -p $OS_PASS --insecure-skip-tls-verify=true
            oc project $PAAS_PROJECT
            oc tag $DOCKER_IMAGE $PAAS_APP:$PAAS_APP
            oc deploy $PAAS_APP
            oc logout
        """
    }
}	

stage('Deploy Image To ENV 2') {
    withCredentials([usernamePassword(credentialsId: env.CREDS_ID, usernameVariable: 'OS_USER', passwordVariable: 'OS_PASS')]) {
        sh """
            oc login $PAAS_SERVER -u $OS_USER -p $OS_PASS --insecure-skip-tls-verify=true
            oc project $PAAS_PROJECT2
            oc tag $DOCKER_IMAGE $PAAS_APP:$PAAS_APP
            oc deploy $PAAS_APP
            oc logout
        """
    }
}
```
